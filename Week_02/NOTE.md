##  二叉树

树的遍历：基于递归。树的定义本身，无法有效地进行循环(采用广度优先遍历可以强行循环)

1. 前序(Pre-order)：根-左-右
2. 中序(In-order)：左-根-右
3. 后序(Post-order)：左-右-根

二叉搜索树：中序遍历可以得到升序排列结果。空树也是二叉搜索树。

1. 左子树所有节点的值均小于它的根节点的值；
2. 右子树所有节点的值均大于它的根节点的值；
3. 依次类推：左、右子树也分别为二叉搜索树。(重复性！！！)

二叉搜索树常见操作

1. 查询：O(logn)
2. 插入：O(logn)
3. 删除：O(logn)，叶子节点：直接删除；关键节点：用最接近被删节点的节点来代替被删节点。选择第一个小于被删节点的节点(左子树的最右边节点)或者第一个大于被删节点的节点(右子树的最左边节点)，一般选用后者

## 堆

heap：可以迅速找到一堆数中的最大或者最小值的数据结构。

大顶堆(大根堆)：根节点最大的堆

小顶堆(小根堆)：根节点最小的堆

常见堆：二叉堆、斐波那契堆、严格斐波那契堆(性能最好)

以大顶堆为例，常见操作

1. find-max：O(1)
2. delete-max：O(logn)
3. insert(create)：O(logN) or O(1)

二叉堆实现：通过完全二叉树实现(不是二叉搜索树)

二叉堆(大顶)性质

1. 是一颗完全树
2. 树中任意节点的值总是>=其子节点的值

二叉堆实现细节，以大顶堆为例

1. 二叉堆一般都通过“数组”来实现
2. 假设“第一个元素”在数组中的索引为0，则父节点和子节点的位置关系如下：
   1. 根节点(堆顶元素)是：a[0]
   2. 索引为i的左孩子的索引是(2*i+1)
   3. 索引为i的右孩子的索引是(2*i+2)
   4. 索引为i的父节点的索引是floor((i-1)/2)
3. 插入 - O(logn)(树的深度)
   1. 新元素一律先插入到堆的尾部
   2. 依次向上调整(与父节点进行比较)整个堆的结构(一直到根即可)
4. 删除堆顶Delete Max - O(logn)(树的深度)
   1. 将堆尾元素替换到顶部(即堆顶被替代删除掉)
   2. 依次从根部向下调整(与较大的子节点交换)整个堆的结构(一直到堆尾即可)

### 注意：二叉堆是堆(优先队列priority_queue)的一种常见且简单的实现；但并不是最优的实现